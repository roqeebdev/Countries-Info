{"ast":null,"code":"import { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nconst types = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nconst maxDuration = 20000;\n\nfunction calculateDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n\n  while (!state.done && duration < maxDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n\n  return duration;\n}\n\nfunction animateValue(_ref) {\n  let {\n    autoplay = true,\n    delay = 0,\n    driver = frameloopDriver,\n    keyframes: keyframes$1,\n    type = \"keyframes\",\n    repeat = 0,\n    repeatDelay = 0,\n    repeatType = \"loop\",\n    onPlay,\n    onStop,\n    onComplete,\n    onUpdate,\n    ...options\n  } = _ref;\n  let animationDriver;\n  const generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n\n  let mapNumbersToKeyframes;\n\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n\n  const generator = generatorFactory({ ...options,\n    keyframes: keyframes$1\n  });\n  let mirroredGenerator;\n\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory({ ...options,\n      keyframes: [...keyframes$1].reverse(),\n      velocity: -(options.velocity || 0)\n    });\n  }\n\n  let playState = \"idle\";\n  let holdTime = null;\n  let startTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calculateDuration(generator);\n  }\n\n  const {\n    calculatedDuration\n  } = generator;\n  let resolvedDuration = Infinity;\n  let totalDuration = Infinity;\n\n  if (calculatedDuration) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n\n  let currentTime = 0;\n\n  const tick = timestamp => {\n    if (startTime === null) return;\n\n    if (holdTime !== null) {\n      currentTime = holdTime;\n    } else {\n      currentTime = timestamp - startTime;\n    } // Rebase on delay\n\n\n    currentTime = Math.max(currentTime - delay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n\n    if (playState === \"finished\" && holdTime === null) {\n      currentTime = totalDuration;\n    }\n\n    let elapsed = currentTime;\n    let frameGenerator = generator;\n\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = currentTime / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n\n      iterationProgress === 1 && currentIteration--;\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n\n      const iterationIsOdd = currentIteration % 2;\n\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n\n      const p = currentTime >= totalDuration ? repeatType === \"reverse\" && iterationIsOdd ? 0 : 1 : clamp(0, 1, iterationProgress);\n      elapsed = p * resolvedDuration;\n    }\n\n    const state = frameGenerator.next(elapsed);\n    let {\n      value,\n      done\n    } = state;\n\n    if (onUpdate) {\n      onUpdate(mapNumbersToKeyframes ? mapNumbersToKeyframes(value) : value);\n    }\n\n    if (calculatedDuration !== null) {\n      done = currentTime >= totalDuration;\n    }\n\n    const isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done);\n\n    if (isAnimationFinished) {\n      playState = \"finished\";\n      onComplete && onComplete();\n      animationDriver && animationDriver.stop();\n    }\n\n    return state;\n  };\n\n  const play = () => {\n    animationDriver = driver(tick);\n    const now = animationDriver.now();\n    onPlay && onPlay();\n    playState = \"running\";\n\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime) {\n      // TODO When implementing play/pause, check WAAPI\n      // logic around finished animations\n      startTime = now;\n    }\n\n    holdTime = null;\n    animationDriver.start();\n  };\n\n  if (autoplay) {\n    play();\n  }\n\n  const controls = {\n    get currentTime() {\n      return millisecondsToSeconds(currentTime);\n    },\n\n    set currentTime(newTime) {\n      if (holdTime !== null || !animationDriver) {\n        holdTime = 0;\n      } else {\n        startTime = animationDriver.now() - secondsToMilliseconds(newTime);\n      }\n    },\n\n    stop: () => {\n      onStop && onStop();\n      animationDriver && animationDriver.stop();\n    },\n    sample: elapsed => {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\n\nexport { animateValue };","map":{"version":3,"names":["keyframes","spring","inertia","frameloopDriver","interpolate","clamp","millisecondsToSeconds","secondsToMilliseconds","types","decay","tween","maxDuration","calculateDuration","generator","duration","timeStep","state","next","done","animateValue","autoplay","delay","driver","keyframes$1","type","repeat","repeatDelay","repeatType","onPlay","onStop","onComplete","onUpdate","options","animationDriver","generatorFactory","mapNumbersToKeyframes","mirroredGenerator","reverse","velocity","playState","holdTime","startTime","calculatedDuration","resolvedDuration","Infinity","totalDuration","currentTime","tick","timestamp","Math","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","iterationIsOdd","p","value","isAnimationFinished","stop","play","now","start","controls","newTime","sample"],"sources":["/Users/macbook/Downloads/country_details/node_modules/framer-motion/dist/es/animation/js/index.mjs"],"sourcesContent":["import { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nfunction calculateDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration;\n}\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calculateDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            currentTime = timestamp - startTime;\n        }\n        // Rebase on delay\n        currentTime = Math.max(currentTime - delay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            const p = currentTime >= totalDuration\n                ? repeatType === \"reverse\" && iterationIsOdd\n                    ? 0\n                    : 1\n                : clamp(0, 1, iterationProgress);\n            elapsed = p * resolvedDuration;\n        }\n        const state = frameGenerator.next(elapsed);\n        let { value, done } = state;\n        if (onUpdate) {\n            onUpdate(mapNumbersToKeyframes ? mapNumbersToKeyframes(value) : value);\n        }\n        if (calculatedDuration !== null) {\n            done = currentTime >= totalDuration;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" || (playState === \"running\" && done));\n        if (isAnimationFinished) {\n            playState = \"finished\";\n            onComplete && onComplete();\n            animationDriver && animationDriver.stop();\n        }\n        return state;\n    };\n    const play = () => {\n        animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        playState = \"running\";\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime) {\n            // TODO When implementing play/pause, check WAAPI\n            // logic around finished animations\n            startTime = now;\n        }\n        holdTime = null;\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        get currentTime() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set currentTime(newTime) {\n            if (holdTime !== null || !animationDriver) {\n                holdTime = 0;\n            }\n            else {\n                startTime =\n                    animationDriver.now() - secondsToMilliseconds(newTime);\n            }\n        },\n        stop: () => {\n            onStop && onStop();\n            animationDriver && animationDriver.stop();\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}